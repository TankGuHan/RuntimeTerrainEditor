<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XFrameworkRuntime</name>
    </assembly>
    <members>
        <member name="T:XFramework.Entity">
            <summary>
            单位实体
            </summary>
        </member>
        <member name="M:XFramework.Entity.OnInit">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:XFramework.Entity.OnShow">
            <summary>
            显示
            </summary>
        </member>
        <member name="M:XFramework.Entity.OnHide">
            <summary>
            隐藏
            </summary>
        </member>
        <member name="M:XFramework.Entity.OnAttached(XFramework.Entity)">
            <summary>
            附加子实体
            </summary>
            <param name="childEntity">子实体</param>
        </member>
        <member name="M:XFramework.Entity.OnDetached(XFramework.Entity)">
            <summary>
            移除子实体
            </summary>
            <param name="parentEntity">子实体</param>
        </member>
        <member name="M:XFramework.Entity.OnAttachTo(XFramework.Entity)">
            <summary>
            附加到别的实体上
            </summary>
            <param name="parentEntity">父实体</param>
        </member>
        <member name="M:XFramework.Entity.OnDetachFrom(XFramework.Entity)">
            <summary>
            被别的实体移除
            </summary>
            <param name="parentEntity">父实体</param>
        </member>
        <member name="M:XFramework.Entity.OnUpdate(System.Single,System.Single)">
            <summary>
            轮询
            </summary>
        </member>
        <member name="T:XFramework.EntityManager">
            <summary>
            实体管理器
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.m_Id">
            <summary>
            实体id，创建实体时用
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.m_EntityContainerDic">
            <summary>
            存储对应实体容器的字典
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.AddTemplate``1(UnityEngine.GameObject)">
            <summary>
            添加模板
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.AddTemplate``1(System.String,UnityEngine.GameObject)">
            <summary>
            添加模板
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.AddTemplate(System.String,System.Type,UnityEngine.GameObject)">
            <summary>
            设置模板
            </summary>
            <param name="key">key</param>
            <param name="type">类型</param>
            <param name="template">模板</param>
        </member>
        <member name="M:XFramework.EntityManager.Instantiate``1(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            实例化实体
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.EntityManager.GetContainer(System.String)">
            <summary>
            获取实体容器
            </summary>
            <param name="entityName">实体名</param>
        </member>
        <member name="M:XFramework.EntityManager.GetEntity(UnityEngine.GameObject)">
            <summary>
            获取实体
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.GetEntity(System.Int32)">
            <summary>
            获取实体
            </summary>
            <param name="entityId">实体Id</param>
        </member>
        <member name="M:XFramework.EntityManager.GetEntities(System.String)">
            <summary>
            获取同名的所有实体
            </summary>
            <param name="entityName"></param>
        </member>
        <member name="M:XFramework.EntityManager.Clean(System.Boolean)">
            <summary>
            清除未在使用的实体
            </summary>
            <param name="deleteUselessContainer">是否删除不含实体的容器</param>
        </member>
        <member name="T:XFramework.EntityManager.EntityContainer">
            <summary>
            实体容器
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.EntityContainer.name">
            <summary>
            容器名
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.EntityContainer.type">
            <summary>
            容器类型
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.EntityContainer.m_Entities">
            <summary>
            实体列表
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.EntityContainer.m_Template">
            <summary>
            对象池
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.EntityContainer.Instantiate(System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            实例化物体
            </summary>
            <param name="pos">位置</param>
            <param name="quaternion">角度</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.EntityManager.EntityContainer.GetEntities">
            <summary>
            获取容器中的所有实体
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.EntityContainer.OnUpdate(System.Single,System.Single)">
            <summary>
            轮询
            </summary>
            <param name="elapseSeconds">逻辑运行时间</param>
            <param name="realElapseSeconds">实际运行时间</param>
        </member>
        <member name="F:XFramework.EntityManager.Pool`1.template">
            <summary>
            对象池模板
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.Pool`1.pooledObjects">
            <summary>
            对象池链表
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.Pool`1.currentIndex">
            <summary>
            当前指向链表位置索引
            </summary>
        </member>
        <member name="F:XFramework.EntityManager.Pool`1.maxCount">
            <summary>
            池的最大容量
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.Pool`1.#ctor(UnityEngine.GameObject,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="template"></param>
            <param name="maxCount"></param>
        </member>
        <member name="M:XFramework.EntityManager.Pool`1.Clear">
            <summary>
            将对象池的数量回归5
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.Pool`1.Allocate">
            <summary>
            获取对象池中可以使用的对象。
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.Pool`1.Recycle(XFramework.Entity)">
            <summary>
            回收
            </summary>
        </member>
        <member name="M:XFramework.EntityManager.Pool`1.Create(UnityEngine.GameObject,System.Boolean)">
            <summary>
            为对象池新增一个对象
            </summary>
        </member>
        <member name="T:XFramework.Fsm`1">
            <summary>
            状态机
            </summary>
            <typeparam name="TState">子类状态机对应的状态基类</typeparam>
        </member>
        <member name="F:XFramework.Fsm`1.m_StateDic">
            <summary>
            存储该状态机包含的所有状态
            </summary>
        </member>
        <member name="M:XFramework.Fsm`1.GetState``1">
            <summary>
            获取一个状态
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XFramework.Fsm`1.CreateState``1">
            <summary>
            创建一个状态
            </summary>
        </member>
        <member name="M:XFramework.Fsm`1.GetCurrentState">
            <summary>
            获取当前状态
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.Fsm`1.StartFsm``1">
            <summary>
            开启状态机
            </summary>
            <typeparam name="KState"></typeparam>
        </member>
        <member name="M:XFramework.Fsm`1.ChangeState``1">
            <summary>
            状态切换
            </summary>
            <typeparam name="KState"></typeparam>
        </member>
        <member name="T:XFramework.IFsm">
            <summary>
            状态机接口
            </summary>
        </member>
        <member name="P:XFramework.IFsm.CurrentState">
            <summary>
            状态机当前状态
            </summary>
        </member>
        <member name="P:XFramework.IFsm.IsActive">
            <summary>
            状态机是否激活
            </summary>
        </member>
        <member name="M:XFramework.IFsm.OnUpdate">
            <summary>
            每帧调用
            </summary>
        </member>
        <member name="M:XFramework.IFsm.StartFsm``1">
            <summary>
            从某一状态开始一个状态机
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.IFsm.ChangeState``1">
            <summary>
            状态切换
            </summary>
        </member>
        <member name="T:XFramework.FsmManager">
            <summary>
            状态机管理类
            </summary>
        </member>
        <member name="F:XFramework.FsmManager.m_FsmDic">
            <summary>
            存储所有状态机的字典
            </summary>
        </member>
        <member name="P:XFramework.FsmManager.Count">
            <summary>
            状态机的数量
            </summary>
        </member>
        <member name="M:XFramework.FsmManager.OnUpdate">
            <summary>
            每帧调用处于激活状态的状态机
            </summary>
        </member>
        <member name="M:XFramework.FsmManager.HasFsm``1">
            <summary>
            是否包含某种状态机
            </summary>
        </member>
        <member name="M:XFramework.FsmManager.HasFsm(System.Type)">
            <summary>
            是否包含某种状态机
            </summary>
        </member>
        <member name="M:XFramework.FsmManager.GetFsm``1">
            <summary>
            获取一个状态机
            </summary>
            <typeparam name="TFsm"></typeparam>
        </member>
        <member name="M:XFramework.FsmManager.GetCurrentState``1">
            <summary>
            获取对应状态机当前所处的状态
            </summary>
            <typeparam name="TFsm"></typeparam>
        </member>
        <member name="M:XFramework.FsmManager.StartFsm``2">
            <summary>
            开启一个状态机
            </summary>
            <typeparam name="TFsm"></typeparam>
            <typeparam name="KState"></typeparam>
        </member>
        <member name="M:XFramework.FsmManager.ChangeState``2">
            <summary>
            切换对应状态机到对应状态
            </summary>
            <typeparam name="TFsm">状态机类型</typeparam>
            <typeparam name="KState">目标状态</typeparam>
        </member>
        <member name="M:XFramework.FsmManager.CreateFsm``1">
            <summary>
            根据类型创建一个状态机
            </summary>
        </member>
        <member name="T:XFramework.FsmState">
            <summary>
            状态基类，考虑要不要改为接口
            </summary>
        </member>
        <member name="T:XFramework.MouseFsm">
            <summary>
            鼠标事件
            </summary>
        </member>
        <member name="P:XFramework.MouseFsm.CurrentMouseState">
            <summary>
            当前鼠标状态
            </summary>
        </member>
        <member name="F:XFramework.MouseFsm.lastPosition">
            <summary>
            鼠标在上一帧的位置
            </summary>
        </member>
        <member name="P:XFramework.MouseFsm.MouseMove">
            <summary>
            鼠标是否移动
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnLeftButtonHold">
            <summary>
            左键保持按下状态
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnLeftButtonUp">
            <summary>
            左键抬起
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnRightButtonDown">
            <summary>
            右键按下
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnRightButtonHold">
            <summary>
            右键保持按下状态
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnRightButtonUp">
            <summary>
            右键抬起
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnCenterButtonDown">
            <summary>
            右键按下
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnCenterButtonHold">
            <summary>
            右键保持按下状态
            </summary>
        </member>
        <member name="M:XFramework.MouseState.OnCenterButtonUp">
            <summary>
            右键抬起
            </summary>
        </member>
        <member name="T:XFramework.OldFsm.Transition">
            <summary>
            ״̬ת������
            </summary>
        </member>
        <member name="T:XFramework.OldFsm.FSMStateID">
            <summary>
            ״̬
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.AdvancedFSM.AddFSMState(XFramework.OldFsm.FSMState)">
            <summary>
            Add New State into the list
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.AdvancedFSM.PerformTransition(XFramework.OldFsm.Transition)">
            <summary>
            This method tries to change the state the FSM is in based on
            the current state and the transition passed. 
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.enemy">
            <summary>
            攻击目标
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.attackPos">
            <summary>
            攻击目标点
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.targetPos">
            <summary>
            移动目标点
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.shootRate">
            <summary>
            攻击时间间隔
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.time">
            <summary>
            时间
            </summary>
        </member>
        <member name="F:XFramework.OldFsm.FSM.timer">
            <summary>
            时间控制
            </summary>
        </member>
        <!-- 对于成员“T:XFramework.OldFsm.FSMState”忽略有格式错误的 XML 注释 -->
        <member name="M:XFramework.OldFsm.FSMState.DeleteTransition(XFramework.OldFsm.Transition)">
            <summary>
            This method deletes a pair transition-state from this state´s map.    
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.FSMState.GetOutputState(XFramework.OldFsm.Transition)">
            <summary>
            This method returns the new state the FSM should be if
               this state receives a transition  
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.FSMState.Reason(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Decides if the state should transition to another on its list
            NPC is a reference to the npc tha is controlled by this class
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.FSMState.Act(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            This method controls the behavior of the NPC in the game World.
            Every action, movement or communication the NPC does should be placed here
            NPC is a reference to the npc tha is controlled by this class
            </summary>
        </member>
        <member name="M:XFramework.OldFsm.FSMState.FindNextPoint">
            <summary>
            Find the next semi-random patrol point
            </summary>
        </member>
        <member name="M:XFramework.GameEntry.ModuleUpdate(System.Single,System.Single)">
            <summary>
            每帧运行
            </summary>
            <param name="elapseSeconds">逻辑运行时间</param>
            <param name="realElapseSeconds">真实运行时间</param>
        </member>
        <member name="M:XFramework.GameEntry.GetModule``1">
            <summary>
            获取一个模块
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XFramework.GameEntry.ShutdownModule``1">
            <summary>
            关闭一个模块
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.GameEntry.CreateModule(System.Type)">
            <summary>
            创建一个模块
            </summary>
            <param name="moduleType"></param>
            <returns></returns>
        </member>
        <member name="T:XFramework.GLDraw">
            <summary>
            用于构造几何体Mesh
            </summary>
        </member>
        <member name="M:XFramework.GLDraw.CreateArrow(UnityEngine.Color,System.Single)">
            <summary>
            创建一个轴的箭头网格
            </summary>
        </member>
        <member name="M:XFramework.GLDraw.CreateCube(UnityEngine.Color,UnityEngine.Vector3,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            创建一个方块网格 
            </summary>
        </member>
        <member name="M:XFramework.GLDraw.CreateSphere(System.Int32,System.Single,System.Int32)">
            <summary>
            返回一个球的网格
            </summary>
            <param name="subdivisions"></param>
            <param name="radius"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.GLDraw.CreateCylinder(UnityEngine.Vector3,System.Single,System.Single,System.Int32)">
            <summary>
            圆柱
            </summary>
        </member>
        <member name="M:XFramework.GLDraw.CreatePolygon(UnityEngine.Vector3[],System.Single,System.Int32)">
            <summary>
            凹/凸多边形空域
            </summary>
            <param name="positions"></param>
            <param name="height"></param>
        </member>
        <member name="M:XFramework.GLDraw.CreatePolygon(UnityEngine.Vector3[],System.Int32)">
            <summary>
            凹/凸多边形空域 每个点高度不一样时 可以用来画扇形区域
            </summary>
            <param name="positions"></param>
        </member>
        <member name="M:XFramework.GLDraw.CreateLineMesh_Old(UnityEngine.Vector3[],System.Single,System.Single,System.Int32)">
            <summary>
            立体线，可用于画空中走廊
            </summary>
            <param name="positions">空中走廊所有顶点</param>
        </member>
        <member name="M:XFramework.GLDraw.CreateLineMesh(System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single,System.Int32)">
            <summary>
            立体线，可用于画空中走廊
            </summary>
            <param name="_bottomList">下底面排序</param>
            <param name="_width">宽度</param>
            <param name="_height">高度</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.GLDraw.CreateHemisphere(UnityEngine.Vector3,System.Single,System.Int32,System.Int32)">
            <summary>
            半球
            </summary>
            <param name="pos"></param>
            <param name="radius"></param>
            <param name="angle">默认为半球，通过修改角度可以修改球的缺省</param>
        </member>
        <member name="M:XFramework.GLDraw.CreatConvexPolgonao(UnityEngine.Vector3[],System.Single,System.Int32)">
            <summary>
            凸多边形
            </summary>
            <param name="positions">所有底面顶点集合</param>
            <param name="height">按照高度从底面点向上的延伸顶面点</param>
        </member>
        <member name="T:XFramework.GraphicsManager">
            <summary>
            GL管理器
            </summary>
        </member>
        <member name="F:XFramework.GraphicsManager.m_GraphicsDic">
            <summary>
            渲染列表
            </summary>
        </member>
        <member name="P:XFramework.GraphicsManager.InternalColoredMat">
            <summary>
            内置shader，可用于画线
            </summary>
        </member>
        <member name="P:XFramework.GraphicsManager.InternalClearMat">
            <summary>
            内置shader
            </summary>
        </member>
        <member name="P:XFramework.GraphicsManager.InternalErrorMat">
            <summary>
            内置shader
            </summary>
        </member>
        <member name="M:XFramework.GraphicsManager.AddGraphics(UnityEngine.Camera,XFramework.IDraw)">
            <summary>
            添加一个渲染任务
            </summary>
            <param name="camera"></param>
            <param name="paniter"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.AddGraphics(UnityEngine.Camera,System.Action)">
            <summary>
            添加一个渲染任务
            </summary>
            <param name="camera"></param>
            <param name="action"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.RemoveGraphics(UnityEngine.Camera,XFramework.IDraw)">
            <summary>
            移除一个渲染任务
            </summary>
            <param name="camera"></param>
            <param name="paniter"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.RemoveGraphics(UnityEngine.Camera,System.Action)">
            <summary>
            移除一个渲染任务
            </summary>
            <param name="camera"></param>
            <param name="action"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.OpenGraphics(UnityEngine.Camera)">
            <summary>
            打开一个渲染层
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.CloseGraphics(UnityEngine.Camera)">
            <summary>
            关闭一个渲染层
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:XFramework.GraphicsManager.ClearGraphics(UnityEngine.Camera)">
            <summary>
            清空一个渲染队列的所有渲染任务
            </summary>
            <param name="camera"></param>
        </member>
        <member name="T:XFramework.GraphicsMono">
            <summary>
            用于在屏幕上绘制图形
            </summary>
        </member>
        <member name="F:XFramework.GraphicsMono.m_IsActive">
            <summary>
            是否激活
            </summary>
        </member>
        <member name="F:XFramework.GraphicsMono.m_Painters">
            <summary>
            绘制者集合
            </summary>
        </member>
        <member name="F:XFramework.GraphicsMono.m_Action">
            <summary>
            绘制方法
            </summary>
        </member>
        <member name="M:XFramework.GraphicsMono.AddGraphics(XFramework.IDraw)">
            <summary>
            添加一个绘制者
            </summary>
            <param name="paniter"></param>
        </member>
        <member name="M:XFramework.GraphicsMono.AddGraphics(System.Action)">
            <summary>
            添加一个绘制方法
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:XFramework.GraphicsMono.RemoveGraphics(XFramework.IDraw)">
            <summary>
            移除一个绘制者
            </summary>
            <param name="paniter"></param>
        </member>
        <member name="M:XFramework.GraphicsMono.RemoveGraphics(System.Action)">
            <summary>
            移除一个绘制方法
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:XFramework.GraphicsMono.Clear">
            <summary>
            清楚所有绘制
            </summary>
        </member>
        <member name="M:XFramework.GraphicsMono.SetActive(System.Boolean)">
            <summary>
            设置状态
            </summary>
            <param name="isActive"></param>
        </member>
        <member name="T:XFramework.IGameModule">
            <summary>
            模块基类
            </summary>
        </member>
        <member name="P:XFramework.IGameModule.Priority">
            <summary>
            模块优先级
            </summary>
            <remarks>优先级较高的模块会优先轮询</remarks>
        </member>
        <member name="M:XFramework.IGameModule.Update(System.Single,System.Single)">
            <summary>
            游戏框架模块轮询
            </summary>
            <param name="elapseSeconds">逻辑运行时间，以秒为单位</param>
            <param name="realElapseSeconds">真实运行时间，以秒为单位</param>
        </member>
        <member name="M:XFramework.IGameModule.Shutdown">
            <summary>
            关闭模块
            </summary> 
        </member>
        <member name="T:XFramework.MessengerManager">
            <summary>
            消息类 全局类消息
            </summary>
        </member>
        <member name="T:XFramework.Net.Connection">
            <summary>
            连接信息
            </summary>
        </member>
        <member name="F:XFramework.Net.Connection.m_ReadBuff">
            <summary>
            缓冲区
            </summary>
        </member>
        <member name="F:XFramework.Net.Connection.m_BufferCount">
            <summary>
            有效缓冲大小
            </summary>
        </member>
        <member name="F:XFramework.Net.Connection.m_Socket">
            <summary>
            套接字
            </summary>
        </member>
        <member name="F:XFramework.Net.Connection.m_Callback">
            <summary>
            回调事件
            </summary>
        </member>
        <member name="P:XFramework.Net.Connection.m_BufferRemain">
            <summary>
            缓冲数组剩余空间
            </summary>
        </member>
        <member name="M:XFramework.Net.Connection.GetAdress">
            <summary>
            获取地址
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.Net.Connection.Close">
            <summary>
            关闭连接
            </summary>
        </member>
        <member name="M:XFramework.Net.Connection.BeginReceive(XFramework.Net.ReceiveCallbcak,System.Object)">
            <summary>
            开启数据传输回调
            </summary>
            <param name="callback"></param>
            <param name="state"></param>
        </member>
        <member name="M:XFramework.Net.Connection.ReceiveCb(System.IAsyncResult)">
            <summary>
            数据传输回调
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:XFramework.Net.Connection.ReadData(Net.Common.NetData@)">
            <summary>
            读取一条数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.Net.Connection.Send(System.Int32,System.Byte[])">
            <summary>
            发送数据
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XFramework.Net.Connection.SendAsync(System.Int32,System.Byte[],System.AsyncCallback,System.Object)">
            <summary>
            异步发送数据
            </summary>
            <param name="data">源数据</param>
            <param name="callback">传输完成回调</param>
            <param name="state">包含请求的状态信息的对象</param>
        </member>
        <member name="M:XFramework.Net.Connection.PackageData(System.Byte[])">
            <summary>
            打包数据
            </summary>
            <param name="data">源数据</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Net.NetManager.StartConnect(System.String,System.Int32)">
            <summary>
            开始连接
            </summary>
            <param name="host">主机名</param>
            <param name="port">端口号</param>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:XFramework.Net.NetManager.StartConnectAsync(System.String,System.Int32,System.Action)">
            <summary>
            异步连接
            </summary>
            <param name="host">主机名</param>
            <param name="port">端口号</param>
            <param name="cb">连接成功的回调</param>
            <returns>回调</returns>
        </member>
        <member name="M:XFramework.Net.NetManager.HandleCb(XFramework.Net.Connection)">
            <summary>
            消息处理的回调
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:XFramework.Net.NetManager.Send(System.Int32,System.Byte[])">
            <summary>
            数据发送
            </summary>
            <param name="dataType">数据类型</param>
            <param name="data">数据</param>
        </member>
        <member name="M:XFramework.Net.NetManager.Notify(Net.Common.NetData)">
            <summary>
            消息分发
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XFramework.Net.NetManager.AddListener(System.Enum,XFramework.Net.CallBack)">
            <summary>
            添加事件
            </summary>
            <param name="eventType"></param>
            <param name="callBack"></param>
        </member>
        <member name="M:XFramework.Net.NetManager.RemoveListener(System.Enum,XFramework.Net.CallBack)">
            <summary>
            移除事件
            </summary>
            <param name="eventType"></param>
            <param name="callBack"></param>
        </member>
        <member name="T:XFramework.BaseData">
            <summary>
            观察者数据基类
            </summary>
        </member>
        <member name="P:XFramework.BaseData.dataType">
            <summary>
            这个在派生类中要重写，返回对应的类型
            </summary>
        </member>
        <member name="T:XFramework.DataSubjectManager">
            <summary>
            数据主题管理类
            </summary>
        </member>
        <member name="T:XFramework.DataSubjectManager.Subject">
            <summary>
            每一个Subject都是一个被观察的对象
            </summary>
        </member>
        <member name="F:XFramework.DataSubjectManager.m_SubjectDic">
            <summary>
            存储数据类型和对应主题的字典
            </summary>
        </member>
        <member name="M:XFramework.DataSubjectManager.AddListener(System.Enum,XFramework.IObserver)">
            <summary>
            增加数据监听
            </summary>
            <param name="dataType">数据类型</param>
            <param name="observer">监听这个数据的观察者</param>
        </member>
        <member name="M:XFramework.DataSubjectManager.RemoverListener(System.Enum,XFramework.IObserver)">
            <summary>
            删除数据监听
            </summary>
            <param name="dataType">数据类型</param>
            <param name="observer">监听这个数据的观察者</param>
        </member>
        <member name="M:XFramework.DataSubjectManager.Notify(XFramework.BaseData,System.Int32,System.Object)">
            <summary>
            通知事件
            </summary>
            <param name="data">data主题</param>
            <param name="type">事件类型</param>
            <param name="obj">映射参数</param>
        </member>
        <member name="M:XFramework.ObservableSubjectTemplate`3.Attach(System.Action{`0,`1,`2})">
            <summary>
            添加
            </summary>
        </member>
        <member name="M:XFramework.ObservableSubjectTemplate`3.Detach(System.Action{`0,`1,`2})">
            <summary>
            移除
            </summary>
            <param name="observer"></param>
        </member>
        <member name="M:XFramework.ObservableSubjectTemplate`3.Notify(`0,`1,`2)">
            <summary>
            通知
            </summary>
        </member>
        <member name="T:XFramework.Pool.GameObjectPool">
            <summary>
            对象池
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPool.poolRoot">
            <summary>
            所有对象池的父物体
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPool.objParent">
            <summary>
            当前对象池的父物体
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPool.template">
            <summary>
            对象池模板
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPool.pooledObjects">
            <summary>
            对象池链表
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPool.currentIndex">
            <summary>
            当前指向链表位置索引
            </summary>
        </member>
        <member name="M:XFramework.Pool.GameObjectPool.#ctor(UnityEngine.GameObject,System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="_template"></param>
            <param name="_initCount"></param>
            <param name="_lookPoolSize"></param>
        </member>
        <member name="M:XFramework.Pool.GameObjectPool.Clear">
            <summary>
            将对象池的数量回归5
            </summary>
        </member>
        <member name="M:XFramework.Pool.GameObjectPool.Allocate">
            <summary>
            获取对象池中可以使用的对象。
            </summary>
        </member>
        <member name="M:XFramework.Pool.GameObjectPool.Recycle(XFramework.Pool.GameObjectPoolable)">
            <summary>
            回收
            </summary>
        </member>
        <member name="M:XFramework.Pool.GameObjectPool.Create(UnityEngine.GameObject,System.Boolean)">
            <summary>
            为对象池新增一个对象
            </summary>
        </member>
        <member name="F:XFramework.Pool.GameObjectPoolManager.poolDic">
            <summary>
            利用GameObject的int型Hash值，索引对应的Pool对象
            </summary>
        </member>
        <member name="P:XFramework.Pool.GameObjectPoolManager.PoolTemplateDic">
            <summary>
            所有模型字典
            </summary>
        </member>
        <member name="M:XFramework.Pool.GameObjectPoolManager.CreatPool(UnityEngine.GameObject)">
            <summary>
            创建一个对象池
            </summary>
            <param name="template"></param>
        </member>
        <member name="M:XFramework.Pool.GameObjectPoolManager.Instantiate(System.String,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            通过名字实例化gameobj方法
            </summary>
        </member>
        <member name="T:XFramework.Pool.IPoolable">
            <summary>
            用于泛型约束，要实现SafeObjectPool的类必须继承这个接口
            </summary>
        </member>
        <member name="P:XFramework.Pool.IPoolable.IsRecycled">
            <summary>
            用于表示对象是否被回收
            </summary>
        </member>
        <member name="P:XFramework.Pool.IPoolable.IsLocked">
            <summary>
            是否可以被回收
            </summary>
        </member>
        <member name="M:XFramework.Pool.IPoolable.OnRecycled">
            <summary>
            回收事件
            </summary>
        </member>
        <member name="T:XFramework.Pool.DefultObjectFactory`1">
            <summary>
            一个new出对象的工厂
            </summary>
        </member>
        <member name="T:XFramework.Pool.IObjectFactory`1">
            <summary>
            对象工厂
            </summary>
        </member>
        <member name="T:XFramework.Pool.ObjectPoolManager">
            <summary>
            对象池管理
            </summary>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.HasPool``1">
            <summary>
            是否有T类型的对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.CreatePool``1(System.Int32,System.Int32)">
            <summary>
            创建一个T类型的对象池
            </summary>
            <typeparam name="T">对象池类型</typeparam>
            <param name="initCount">初始数量</param>
            <param name="maxCount">最大数量</param>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.DestoryPool``1">
            <summary>
            销毁一个对象池
            </summary>
            <typeparam name="T"></typeparam>
            <returns>是否成功销毁</returns>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.GetPool``1">
            <summary>
            获取一个对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Allocate``1">
            <summary>
            分配一个对象
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Recycle``1(``0)">
            <summary>
            回收一个对象
            </summary>
            <typeparam name="T"></typeparam>
            <returns>是否回收成功</returns>
        </member>
        <member name="T:XFramework.Pool.ObjectPoolManager.Pool`1">
            <summary>
            内联泛型对象池
            </summary>
            <typeparam name="T">对象池类型</typeparam>
        </member>
        <member name="F:XFramework.Pool.ObjectPoolManager.Pool`1.m_AvailableCache">
            <summary>
            可用的对象
            </summary>
        </member>
        <member name="F:XFramework.Pool.ObjectPoolManager.Pool`1.m_OccupiedCache">
            <summary>
            被占有的对象
            </summary>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.#ctor(System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="_initCount"></param>
            <param name="_lookPoolSize"></param>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.Allocate">
            <summary>
            获取对象池中可以使用的对象。
            </summary>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.Recycle(`0)">
            <summary>
            回收
            </summary>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.AutoRecycle">
            <summary>
            自动回收
            </summary>
            <returns>本次操作回收对象的数量</returns>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.OnDestroy">
            <summary>
            销毁自身
            </summary>
        </member>
        <member name="M:XFramework.Pool.ObjectPoolManager.Pool`1.Create">
            <summary>
            创建一个新对象
            </summary>
        </member>
        <member name="F:XFramework.Pool.PoolBase.initCount">
            <summary>
            初始化大小
            </summary>
        </member>
        <member name="F:XFramework.Pool.PoolBase.maxCount">
            <summary>
            对象池最大数量
            </summary>
        </member>
        <member name="M:XFramework.Pool.PoolBase.AutoRecycle">
            <summary>
            自动回收对象池中的对象
            </summary>
        </member>
        <member name="M:XFramework.Pool.PoolBase.OnDestroy">
            <summary>
            销毁对象池
            </summary>
        </member>
        <member name="T:XFramework.ProcedureFsm">
            <summary>
            流程状态机
            </summary>
        </member>
        <member name="T:XFramework.ProcedureManager">
            <summary>
            流程的优先级应比状态机低
            </summary>
        </member>
        <member name="F:XFramework.ProcedureManager.m_Fsm">
            <summary>
            流程状态机
            </summary>
        </member>
        <member name="M:XFramework.ProcedureManager.StartProcedure``1">
            <summary>
            开启一个流程
            </summary>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="M:XFramework.ProcedureManager.ChangeProcedure``1">
            <summary>
            流程切换
            </summary>
            <typeparam name="TProcedure"></typeparam>
        </member>
        <member name="M:XFramework.ProcedureManager.GetCurrentProcedure">
            <summary>
            获取当前流程
            </summary>
            <returns></returns>
        </member>
        <member name="F:XFramework.SoundManager.m_BGM">
            <summary>
            背景音乐
            </summary>
        </member>
        <member name="F:XFramework.SoundManager.m_SFX2D">
            <summary>
            2D音效
            </summary>
        </member>
        <member name="F:XFramework.SoundManager.m_SFX3D">
            <summary>
            3D音效
            </summary>
        </member>
        <member name="M:XFramework.SoundManager.PlayBGM(System.String)">
            <summary>
            播放背景音乐
            </summary>
            <param name="bgmName">背景音乐名</param>
        </member>
        <member name="M:XFramework.SoundManager.GetAudioClip(System.String)">
            <summary>
            获取音频
            </summary>
        </member>
        <member name="T:XFramework.Tasks.BaseTask">
            <summary>
            任务基类
            </summary>
        </member>
        <member name="P:XFramework.Tasks.BaseTask.Next">
            <summary>
            下一个任务
            </summary>
        </member>
        <member name="P:XFramework.Tasks.BaseTask.IsDone">
            <summary>
            当前任务是否完成
            </summary>
        </member>
        <member name="M:XFramework.Tasks.BaseTask.Update">
            <summary>
            任务完成前每帧执行
            </summary>
        </member>
        <member name="M:XFramework.Tasks.BaseTask.All(XFramework.Tasks.ITask[])">
            <summary>
            创建一个所有任务执行完才会继续执行下一个任务的队列任务
            </summary>
            <param name="tasks"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Tasks.BaseTask.Race(XFramework.Tasks.ITask[])">
            <summary>
            创建一个任一任务执行完就会继续执行下一个任务的队列任务
            </summary>
            <param name="tasks"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Tasks.BaseTask.Then(XFramework.Tasks.ITask)">
            <summary>
            创建一个后续任务
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="T:XFramework.Tasks.SingleTask">
            <summary>
            单个任务
            </summary>
        </member>
        <member name="T:XFramework.Tasks.RaceTask">
            <summary>
            任务组（组内任一任务完成就算完成）
            </summary>
        </member>
        <member name="F:XFramework.Tasks.RaceTask.m_Tasks">
            <summary>
            任务组
            </summary>
        </member>
        <member name="T:XFramework.Tasks.AllTask">
            <summary>
            任务组（组内所有任务完成算完成）
            </summary>
        </member>
        <member name="F:XFramework.Tasks.AllTask.m_Tasks">
            <summary>
            任务组
            </summary>
        </member>
        <member name="T:XFramework.Tasks.TaskManager">
            <summary>
            任务管理器
            每帧会产生40B的GC
            </summary>
        </member>
        <member name="T:XFramework.Tasks.TaskState">
            <summary>
            任务状态
            </summary>
        </member>
        <member name="F:XFramework.Tasks.TaskState.Waiting">
            <summary>
            等待中
            </summary>
        </member>
        <member name="F:XFramework.Tasks.TaskState.Running">
            <summary>
            运行中
            </summary>
        </member>
        <member name="F:XFramework.Tasks.TaskState.Completed">
            <summary>
            已完成
            </summary>
        </member>
        <member name="F:XFramework.Tasks.TaskState.Failed">
            <summary>
            已失败
            </summary>
        </member>
        <member name="F:XFramework.Tasks.TaskState.Canceled">
            <summary>
            已取消
            </summary>
        </member>
        <member name="T:XFramework.UI.BaseItem">
            <summary>
            UI元素数据类
            </summary>
        </member>
        <member name="F:XFramework.UI.BaseItem.transform">
            <summary>
            对应的Transform
            </summary>
        </member>
        <member name="T:XFramework.UI.BasePanel">
            <summary>
            面板基类
            </summary>
        </member>
        <member name="P:XFramework.UI.BasePanel.Level">
            <summary>
            UI层级,层级最低的显示在底层
            </summary>
        </member>
        <member name="P:XFramework.UI.BasePanel.Name">
            <summary>
            面板名
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.Init(UnityEngine.GameObject,System.String)">
            <summary>
            面板初始化，只会执行一次，在Awake后start前执行
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.Reg">
            <summary>
            初始化UI组件
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.OnOpen">
            <summary>
            界面显示
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.OnUpdate">
            <summary>
            每帧运行
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.OnPause">
            <summary>
            界面暂停,被遮挡
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.OnResume">
            <summary>
            界面恢复
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.OnClose">
            <summary>
            退出界面，界面被关闭
            </summary>
        </member>
        <member name="M:XFramework.UI.BasePanel.InitGUIDic">
            <summary>
            初始化UI组件字典
            </summary>
        </member>
        <member name="P:XFramework.UI.BasePanel.Item(System.String)">
            <summary>
            Find UI组件的索引器
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.globalMousePos">
            <summary>
            鼠标在UI坐标上的位置
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.differ">
            <summary>
            鼠标落在面板上的位置和面板位置差
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.isMovable">
            <summary>
            可移动性
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.horizontal">
            <summary>
            水平方向
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.vertical">
            <summary>
            竖直方向
            </summary>
        </member>
        <member name="F:XFramework.UI.Draggable.limitByParent">
            <summary>
            范围限制
            </summary>
        </member>
        <member name="T:XFramework.UI.LongOrDoubleBtn">
            <summary>
            可长按按钮
            </summary>
        </member>
        <member name="F:XFramework.UI.LongOrDoubleBtn.isLongPressTrigger">
            <summary>
            是否为长按
            </summary>
        </member>
        <member name="F:XFramework.UI.LongOrDoubleBtn.maxTime">
            <summary>
            长按最大时间，超过后系数为1
            单位 秒
            </summary>
        </member>
        <member name="T:XFramework.UI.Tree">
            <summary>
            目录树
            </summary>
        </member>
        <member name="P:XFramework.UI.Tree.NodeTemplate">
            <summary>
            模板
            </summary>
        </member>
        <member name="F:XFramework.UI.Tree.m_RootTreeNode">
            <summary>
            树的根节点
            </summary>
        </member>
        <member name="F:XFramework.UI.Tree.onSelectNode">
            <summary>
            节点被选中的事件
            </summary>
        </member>
        <member name="F:XFramework.UI.Tree.onOn_Off">
            <summary>
            节点展开关闭事件
            </summary>
        </member>
        <member name="M:XFramework.UI.Tree.GenerateTree(XFramework.UI.TreeNode)">
            <summary>
            构造一棵树
            </summary>
            <param name="rootNode">父子关系已经设置好的根节点</param>
        </member>
        <member name="M:XFramework.UI.Tree.Delete(System.String)">
            <summary>
            删除某个节点
            </summary>
            <param name="path">路径</param>
        </member>
        <member name="M:XFramework.UI.Tree.Delete">
            <summary>
            树的自删除
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.Tree.GetTreeHeight">
            <summary>
            获取树的长度
            </summary>
            <returns></returns>
        </member>
        <member name="T:XFramework.UI.TreeNode">
            <summary>
            树节点
            </summary>
        </member>
        <member name="F:XFramework.UI.TreeNode.m_Tree">
            <summary>
            当前结点所归属的树
            </summary>
        </member>
        <member name="F:XFramework.UI.TreeNode.m_Childs">
            <summary>
            子结点
            </summary>
        </member>
        <member name="F:XFramework.UI.TreeNode.m_Parent">
            <summary>
            父结点
            </summary>
        </member>
        <member name="F:XFramework.UI.TreeNode.m_IsOn">
            <summary>
            开启状态
            </summary>
        </member>
        <member name="F:XFramework.UI.TreeNode.m_Level">
            <summary>
            层级
            </summary>
        </member>
        <member name="P:XFramework.UI.TreeNode.Text">
            <summary>
            显示文字
            </summary>
        </member>
        <member name="P:XFramework.UI.TreeNode.Root">
            <summary>
            根结点
            </summary>
        </member>
        <member name="P:XFramework.UI.TreeNode.ChildCount">
            <summary>
            子节点数量
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.RefreshView(System.Boolean)">
            <summary>
            刷新显示隐藏
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.RefreshPos">
            <summary>
            刷新位置
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.AddChild(XFramework.UI.TreeNode)">
            <summary>
            添加一个父子关系
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.TreeNode.CreateTree(XFramework.UI.Tree)">
            <summary>
            创建一个棵树并刷新位置
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.CreateChild(XFramework.UI.TreeNode)">
            <summary>
            添加一个父子关系并创建实体
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.TreeNode.Delete">
            <summary>
            删除自身
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.InternalCreateTree(XFramework.UI.Tree)">
            <summary>
            根据已有的父子关系创建一颗（子）树
            </summary>
            <param name="m_Parent"></param>
            <param name="gameObject"></param>
        </member>
        <member name="M:XFramework.UI.TreeNode.InitEnity(XFramework.UI.Tree)">
            <summary>
            初始化场景中对应的实体
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:XFramework.UI.TreeNode.SetToggle(System.Boolean)">
            <summary>
            设置Toggle的显示隐藏
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.GetItemCount">
            <summary>
            所有子物体的数量 +1, 不仅仅是下一级
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.GetSiblingIndex">
            <summary>
            获取自己在父物体种的索引
            </summary>
        </member>
        <member name="M:XFramework.UI.TreeNode.SetParent(XFramework.UI.TreeNode)">
            <summary>
            重置父物体
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:XFramework.UI.TreeNode.Find(System.String)">
            <summary>
            通过字符串找寻子节点
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.TreeNode.GetChild(System.Int32)">
            <summary>
            根据索引获取子节点
            </summary>
        </member>
        <member name="F:XFramework.UI.GULayoutGroup.m_EntityTemplate">
            <summary>
            实体模板
            </summary>
        </member>
        <member name="F:XFramework.UI.GULayoutGroup.onEntityRecycle">
            <summary>
            实体回收事件
            </summary>
        </member>
        <member name="F:XFramework.UI.GULayoutGroup.onEntityCreate">
            <summary>
            实体创建事件
            </summary>
        </member>
        <member name="F:XFramework.UI.GULayoutGroup.onEntityAdd">
            <summary>
            实体添加事件
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.Start">
            <summary>
            内容模板
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.AddEntity">
            <summary>
            添加实体
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.RemoveEntity(UnityEngine.GameObject)">
            <summary>
            移除实体
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.RemoveEntity(System.Int32)">
            <summary>
            移除实体
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.ConfigEntity(System.Int32)">
            <summary>
            配置实体数量
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.CreateEntity">
            <summary>
            创建一个实体并返回，后期改为从对象池中获取
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.Clear">
            <summary>
            删除所有子物体
            </summary>
        </member>
        <member name="M:XFramework.UI.GULayoutGroup.SetEntity(UnityEngine.GameObject)">
            <summary>
            设置实体模板
            </summary>
            <param name="template">模板</param>
        </member>
        <member name="T:XFramework.UI.IUIManager">
            <summary>
            UI管理器接口
            </summary>
        </member>
        <member name="M:XFramework.UI.IUIManager.OpenPanel(System.String)">
            <summary>
            打开面板
            </summary>
        </member>
        <member name="M:XFramework.UI.IUIManager.ClosePanel(System.String)">
            <summary>
            关闭面板
            </summary>
        </member>
        <member name="M:XFramework.UI.IUIManager.GetPanel(System.String)">
            <summary>
            获取面板
            </summary>
        </member>
        <member name="M:XFramework.UI.IUIManager.CloseTopPanel">
            <summary>
            关闭最近一次打开的面板
            </summary>
        </member>
        <member name="T:XFramework.UI.UIMgrDicType">
            <summary>
            一个使用字典管理的UI管理器
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrDicType.m_PanelPathDict">
            <summary>
            存储所有面板Prefab的路径
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrDicType.m_PanelDict">
            <summary>
            保存所有实例化面板的游戏物体身上的BasePanel组件
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrDicType.m_OnDisplayPanelDic">
            <summary>
            处于打开状态的面板字典，key为层级
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.OpenPanel(System.String)">
            <summary>
            打开面板
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.ClosePanel(System.String)">
            <summary>
            关闭面板
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.GetPanel(System.String)">
            <summary>
            获取面板
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.CloseTopPanel">
            <summary>
            关闭最上层界面
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.CloseLevelPanel(System.Int32)">
            <summary>
            关闭某一层级的所有面板
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrDicType.InitPathDic">
            <summary>
            初始化面板预制体路径字典
            </summary>
        </member>
        <member name="T:XFramework.UI.UIMgrStackType">
            <summary>
            栈入式UI管理器
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrStackType.m_PanelPathDict">
            <summary>
            存储所有面板Prefab的路径
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrStackType.m_PanelDict">
            <summary>
            保存所有实例化面板的游戏物体身上的BasePanel组件
            </summary>
        </member>
        <member name="F:XFramework.UI.UIMgrStackType.m_PanelStack">
            <summary>
            存储面板的栈
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.PushPanel(System.String)">
            <summary>
            把某个页面入栈，  把某个页面显示在界面上
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.PopPanel">
            <summary>
            出栈 ，把页面从界面上移除
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.GetPanel(System.String)">
            <summary>
            根据面板类型 得到实例化的面板
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.GetPanel``1(System.String)">
            <summary>
            返回特定类型的panel
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.TopPanelEqual(System.String)">
            <summary>
            判断栈顶界面是否为某一个类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:XFramework.UI.UIMgrStackType.TopPanel">
            <summary>
            栈顶界面
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.TopPanell``1">
            <summary>
            返回一个特定类型的栈顶界面，如果不匹配返回Null
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.CloseAll">
            <summary>
            关闭所有面板
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.InitPathDic">
            <summary>
            初始化面板预制体路径字典
            </summary>
        </member>
        <member name="M:XFramework.UI.UIMgrStackType.Clear">
            <summary>
            清除所有UI面板
            </summary>
        </member>
        <member name="T:XFramework.UI.UIExtFun">
            <summary>
            对Unity UI的扩展方法
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnPointerEnter(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标进入
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnPointerExit(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标移出
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnPointerDown(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标按下
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnPointerUp(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标抬起
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnPointerClick(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标点击（鼠标抬起时已不在原UI上时不会触发，在PointerUp之后调用）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnDrag(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            鼠标拖拽时（鼠标按下不移动不会触发）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnDrop(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            拖拽结束时鼠标不在被拖拽UI上并且在宁外一个UI上时触发（在PointerUp之后）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnScroll(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            滑轮滚动时
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnSelect(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            在被选中时
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnUpdateSelect(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            被选中后的每一帧
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnDeselect(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            结束选中时
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnMove(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            按方向键时
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnSubmit(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            默认为Enter键
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnCancel(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            默认为Esc键
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnInitializePotentialDrag(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            初始化拖拽（在PointerDown之后，PoinerUp之前调用，点击就会调用）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnBeginDrag(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            拖拽开始（鼠标按下不移动不会触发）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddOnEndDrag(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction)">
            <summary>
            拖拽结束（鼠标按下不移动不会触发，在Drop之后）
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddCall(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction,UnityEngine.EventSystems.EventTriggerType)">
            <summary>
            给EventTrigger添加Entry
            </summary>
        </member>
        <member name="M:XFramework.UI.UIExtFun.AddCall(UnityEngine.EventSystems.EventTrigger,UnityEngine.Events.UnityAction{UnityEngine.EventSystems.BaseEventData},UnityEngine.EventSystems.EventTriggerType)">
            <summary>
            提供一种开放BaseEventData的重载
            需要BaseEventData的事件也要写重载
            </summary>
        </member>
        <member name="T:XFramework.UI.GradientColor">
            <summary>
            继承自Graphic的组件都可以添加此效果
            </summary>
        </member>
        <member name="T:XFramework.Collections.Graph`1">
            <summary>
            无向图
            采用邻接多重表存储
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.vertexs">
            <summary>
            图的顶点数组
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.index">
            <summary>
            下一个添加的顶点索值引，当前顶点数量
            </summary>
        </member>
        <member name="M:XFramework.Collections.Graph`1.AddVertex(`0)">
            <summary>
            添加顶点
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XFramework.Collections.Graph`1.AddEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            添加边
            </summary>
            <param name="iIndex"></param>
            <param name="jIndex"></param>
            <param name="weight"></param>
        </member>
        <member name="M:XFramework.Collections.Graph`1.GetShortPath(System.Int32)">
            <summary>
            找寻最短路径startIndex到其余所有点的最短路径,Dijkstra
            </summary>
        </member>
        <member name="M:XFramework.Collections.Graph`1.GetShortPath">
            <summary>
            找寻最短路径i到j短路径,Floyd
            </summary>
        </member>
        <member name="M:XFramework.Collections.Graph`1.Foreach(System.Action{XFramework.Collections.Graph{`0}.Edge})">
            <summary>
            遍历所有边并执行同一操作
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:XFramework.Collections.Graph`1.Edge">
            <summary>
            边表结点
            当Graph为无向图时，head和tail没有首尾之分
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.iIndex">
            <summary>
            无向图：无向边一个顶点对于的下标
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.jIndex">
            <summary>
            无向图：无向边另一个顶点对于的下标
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.iLink">
            <summary>
            无向图：依附headIndex的下一条边
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.jLink">
            <summary>
            无向图：依附tailIndex的下一条边
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.weight">
            <summary>
            存储权值
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.Edge.visited">
            <summary>
            访问标识符
            </summary>
        </member>
        <member name="T:XFramework.Collections.Graph`1.VertexNode">
            <summary>
            顶点表结构
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.VertexNode.data">
            <summary>
            顶点信息
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.VertexNode.firstEdge">
            <summary>
            无向边：指向边表的第一条边
            </summary>
        </member>
        <member name="F:XFramework.Collections.Graph`1.VertexNode.visited">
            <summary>
            访问标识符
            </summary>
        </member>
        <member name="T:XFramework.Collections.GraphDir`1">
            <summary>
            有向图
            采用十字链表存储
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.vertexs">
            <summary>
            图的顶点数组
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.index">
            <summary>
            下一个添加的顶点索值引，当前顶点数量
            </summary>
        </member>
        <member name="M:XFramework.Collections.GraphDir`1.AddVertex(`0)">
            <summary>
            添加顶点
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XFramework.Collections.GraphDir`1.AddEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
            添加边
            </summary>
            <param name="fromIndex"></param>
            <param name="toIndex"></param>
            <param name="weight"></param>
        </member>
        <member name="M:XFramework.Collections.GraphDir`1.GetShortPath(System.Int32)">
            <summary>
            找寻最短路径startIndex到其余所有点的最短路径,Dijkstra
            </summary>
        </member>
        <member name="M:XFramework.Collections.GraphDir`1.GetShortPath">
            <summary>
            找寻最短路径i到j短路径,Floyd
            </summary>
        </member>
        <member name="M:XFramework.Collections.GraphDir`1.Foreach(System.Action{XFramework.Collections.GraphDir{`0}.Edge})">
            <summary>
            遍历所有边并执行同一操作
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:XFramework.Collections.GraphDir`1.Edge">
            <summary>
            边表结点
            当Graph为有向图时,head和tail代表首尾，当Graph为无向图时，head和tail没有首尾之分
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.headIndex">
            <summary>
            有向图：有向边起点对应的下标
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.tailIndex">
            <summary>
            有向图：有向边尾点对应的下标
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.headLink">
            <summary>
            有向图：指向起点相同的下一条边
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.tailLink">
            <summary>
            有向图：指向终点相同的下一条边
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.weight">
            <summary>
            存储权值
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.Edge.visited">
            <summary>
            访问标识符
            </summary>
        </member>
        <member name="T:XFramework.Collections.GraphDir`1.VertexNode">
            <summary>
            顶点表结构
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.VertexNode.data">
            <summary>
            顶点信息
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.VertexNode.firstOut">
            <summary>
            有向边：指向出边表的第一条边，组成邻接表
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.VertexNode.firstIn">
            <summary>
            有向边：指向入边表的第一条边，组成逆邻接表
            </summary>
        </member>
        <member name="F:XFramework.Collections.GraphDir`1.VertexNode.visited">
            <summary>
            访问标识符
            </summary>
        </member>
        <member name="T:XFramework.Draggable">
            <summary>
            2D/3D物体拖拽（需在相机上挂对应的Physics Raycaster）
            </summary>
        </member>
        <member name="F:XFramework.Draggable.is3D">
            <summary>
            空间为3D还是2D
            </summary>
        </member>
        <member name="F:XFramework.Draggable.cloneDrag">
            <summary>
            为true的话会复制一个GameObject作为被拖到的对象
            </summary>
        </member>
        <member name="F:XFramework.Draggable.target">
            <summary>
            拖动目标
            </summary>
        </member>
        <member name="F:XFramework.Draggable.differ">
            <summary>
            鼠标落在面板上的位置和面板位置差
            </summary>
        </member>
        <member name="T:XFramework.DrawTriangles">
            <summary>
            封装所有画三角形的方法
            </summary>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawCylinder(UnityEngine.Vector3[],System.Single,UnityEngine.MeshFilter,UnityEngine.LineRenderer[],UnityEngine.Color)">
            <summary>
            圆柱空域
            </summary>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawWithPointsDifferent(UnityEngine.Vector3[],System.Single,UnityEngine.MeshFilter,UnityEngine.MeshFilter,UnityEngine.Material,UnityEngine.Material)">
            <summary>
            通过两个mesh控制侧面和底面材质不同时(多边形空域)
            </summary>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawPolygon(UnityEngine.Vector3[],System.Single,UnityEngine.MeshFilter,UnityEngine.LineRenderer[],UnityEngine.Color)">
            <summary>
            凹多边形空域
            </summary>
            <param name="positions"></param>
            <param name="height"></param>
            <param name="meshFilter"></param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawPolygon(UnityEngine.Vector3[],UnityEngine.MeshFilter,UnityEngine.LineRenderer[],UnityEngine.Color)">
            <summary>
            凹多边形空域 每个点高度不一样时 可以用来画扇形区域
            </summary>
            <param name="positions"></param>
            <param name="meshFilter"></param>
            <param name="lineRenderers"></param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawAirCorridorSpace(UnityEngine.Vector3[],UnityEngine.MeshFilter,UnityEngine.LineRenderer[],UnityEngine.Color)">
            <summary>
            Resion 1.0 空中走廊
            </summary>
            <param name="positions">空中走廊所有顶点</param>
        </member>
        <member name="M:XFramework.DrawTriangles.GetAirSpaceWithSector(System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single,System.Int32,UnityEngine.MeshFilter)">
            <summary>
            Resion 2.0 带弧形的空中走廊
            </summary>
            <param name="_bottomList">下底面排序</param>
            <param name="_width">宽度</param>
            <param name="_height">高度</param>
            <param name="_squareCount">弧边数量</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawHemisphere(UnityEngine.Vector3,System.Single,UnityEngine.MeshFilter,System.Int32)">
            <summary>
            半球防空区域
            </summary>
            <param name="pos"></param>
            <param name="radius"></param>
            <param name="angle">默认为半球，通过修改角度可以修改球的缺省</param>
            <param name="meshFilter"></param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawLine(UnityEngine.Vector3[],System.Single,UnityEngine.LineRenderer,UnityEngine.Color)">
            <summary>
            线条
            </summary>
            <param name="positions">位置点</param>
            <param name="wide">宽度</param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawWithPoints(UnityEngine.Vector3[],System.Single,UnityEngine.MeshFilter,UnityEngine.LineRenderer[])">
            <summary>
            凸多边型空域
            </summary>
            <param name="positions">所有底面顶点集合</param>
            <param name="height">按照高度从底面点向上的延伸顶面点</param>
            <param name="meshFilter">需要画三角形的mesh</param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawWithPoints(XFramework.Vector3Extend[],UnityEngine.MeshFilter)">
            <summary>
            多边型空域(每个点对应的空域高度不同时)
            </summary>
            <param name="positionDatas">所有底面顶点集合</param>
            <param name="meshFilter">需要画三角形的mesh</param>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawWithPointsDifferent(UnityEngine.Vector3[],System.Single,UnityEngine.MeshFilter,UnityEngine.MeshRenderer,UnityEngine.Material)">
            <summary>
            通过修改一个mesh的子三角形数组材质控制侧面和底面材质不同时(多边形空域)
            </summary>
        </member>
        <member name="M:XFramework.DrawTriangles.DrawPolygon(XFramework.Vector3Extend[],UnityEngine.MeshFilter)">
            <summary>
            凹多边形空域 每个点高度不一样时 可以用来画扇形区域
            </summary>
            <param name="positions"></param>
            <param name="meshFilter"></param>
            <param name="lineRenderers"></param>
        </member>
        <member name="T:XFramework.Vector3Extend">
            <summary>
            带二重高度Vector3
            </summary>
        </member>
        <member name="T:XFramework.Mathematics.Math3d">
            <summary>
            有关3D数学的计算
            有关法向量的计算要求法向量为单位向量
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.AddVectorLength(UnityEngine.Vector3,System.Single)">
            <summary>
            给vector的长度加上size
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.SetVectorLength(UnityEngine.Vector3,System.Single)">
            <summary>
            将vector的长度设为size
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.PlanePlaneIntersection(UnityEngine.Vector3@,UnityEngine.Vector3@,XFramework.Mathematics.Face,XFramework.Mathematics.Face)">
            <summary>
            两个面是否相交
            </summary>
            <param name="linePoint">交线上一点</param>
            <param name="lineVec">交线的方向</param>
            <param name="face_1">平面1法线</param>
            <param name="face_2">平面1上一点</param>
            <returns>是否相交</returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.LinePlaneIntersection(UnityEngine.Vector3@,UnityEngine.Vector3,UnityEngine.Vector3,XFramework.Mathematics.Face)">
            <summary>
            线面是否相交
            </summary>
            <param name="intersection">交点</param>
            <param name="linePoint"></param>
            <param name="lineVec"></param>
            <param name="face"></param>
            <returns>是否相交</returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.LineLineIntersection(UnityEngine.Vector3@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断线与线之间的相交
            </summary>
            <param name="intersection">交点</param>
            <param name="p1">直线1上一点</param>
            <param name="v1">直线1方向</param>
            <param name="p2">直线2上一点</param>
            <param name="v2">直线2方向</param>
            <returns>是否相交</returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.LineLineIntersection(System.Single@,System.Single@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            计算两直线的起点分别到交点的有向距离
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ClosestPointsOnTwoLines(UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            三维空间中两条直线两个最近的点
            </summary>
            <param name="closestPointLine1"></param>
            <param name="closestPointLine2"></param>
            <param name="linePoint1"></param>
            <param name="lineVec1"></param>
            <param name="linePoint2"></param>
            <param name="lineVec2"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ClosestPointsOnTwoLines(System.Single@,System.Single@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            三维空间中两条直线两个最近的点
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <param name="linePoint1"></param>
            <param name="lineVec1"></param>
            <param name="linePoint2"></param>
            <param name="lineVec2"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ClosestPointsOnLineSegment(UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single@,System.Single@,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            两个线段最近的两个点
            </summary>
            <param name="closestPointLine"></param>
            <param name="closestPointSegment"></param>
            <param name="lineT"></param>
            <param name="segmentT"></param>
            <param name="linePoint"></param>
            <param name="lineVec"></param>
            <param name="segmentPoint1"></param>
            <param name="segmentPoint2"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ProjectPointOnLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            一个点在一条直线上的投影点
            </summary>
            <param name="linePoint"></param>
            <param name="lineVec"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ProjectPointOnLineSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
             一个点在一条线段上的投影点
            </summary>
            <param name="linePoint1"></param>
            <param name="linePoint2"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ProjectPointOnPlane(XFramework.Mathematics.Face,UnityEngine.Vector3)">
            <summary>
            空间中一个点在一个面上的投影点
            </summary>
            <param name="face"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.ProjectVectorOnPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            一个向量在一个面上的投影向量
            </summary>
            <param name="planeNormal"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.SignedDistancePlanePoint(XFramework.Mathematics.Face,UnityEngine.Vector3)">
            <summary>
            点到面的距离
            </summary>
            <param name="face"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.AngleVectorPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            一个向量和平面的夹角
            </summary>
            <param name="vector"></param>
            <param name="normal"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.PlaneFrom3Points(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            三个点构造一个平面
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.QuaternionFromMatrix(UnityEngine.Matrix4x4)">
            <summary>
            通过矩阵获取一个四元数
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.PositionFromMatrix(UnityEngine.Matrix4x4)">
            <summary>
            通过矩阵获取一个位置
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.PointOnWhichSideOfLineSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断一个点在一个线段的哪一边
            </summary>
            <param name="linePoint1"></param>
            <param name="linePoint2"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.MouseDistanceToLine(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            鼠标位置到一条线段的距离
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.MouseDistanceToCircle(UnityEngine.Vector3,System.Single)">
            <summary>
            鼠标位置和圆心位置的距离
            </summary>
            <param name="point">圆心点</param>
            <param name="radius">半径</param>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.IsLineInRectangle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断线段是否在矩形内
            </summary>
        </member>
        <member name="M:XFramework.Mathematics.Math3d.IsPointInRectangle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            判断点point是否在矩形内
            </summary>
        </member>
        <member name="T:XFramework.Mathematics.Face">
            <summary>
            表示一个平面
            </summary>
        </member>
        <member name="T:XFramework.ColorInt32">
            <summary>
            此类是为了解决传参类型为Color时不能设置默认值的问题
            </summary>
        </member>
        <member name="T:XFramework.ProtocolBytes">
            <summary>
            提供了一种基于字节流的协议
            </summary>
        </member>
        <member name="M:XFramework.ProtocolBytes.Encode">
            <summary>
            编码器
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.ProtocolBytes.GetDesc">
            <summary>
            协议内容 提取每一个字节并组成字符串 用于查看消息
            </summary>
            <returns></returns>
        </member>
        <member name="M:XFramework.ProtocolBytes.AddString(System.String)">
            <summary>
            将字符转转为字节数组加入字节流
            </summary>
            <param name="str">要添加的字符串</param>
        </member>
        <member name="M:XFramework.ProtocolBytes.GetString">
            <summary>
            将字节数组转化为字符串
            </summary>
            <param name="index">索引起点</param>
            <param name="end">为下一个转换提供索引起点</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.ProtocolBytes.AddInt32(System.Int32)">
            <summary>
            将Int32转化成字节数组加入字节流
            </summary>
            <param name="num">要转化的Int32</param>
        </member>
        <member name="M:XFramework.ProtocolBytes.GetInt32">
            <summary>
            将字节数组转化成Int32
            </summary>
        </member>
        <member name="M:XFramework.ProtocolBytes.AddFloat(System.Single)">
            <summary>
            将float转化成字节数组加入字节流
            </summary>
            <param name="num">要转化的float</param>
        </member>
        <member name="M:XFramework.ProtocolBytes.GetFloat">
            <summary>
            将字节数组转化成float
            </summary>
        </member>
        <member name="M:XFramework.ProtocolBytes.AddDouble(System.Double)">
            <summary>
            将double转化成字节数组加入字节流
            </summary>
            <param name="num">要转化的double</param>
        </member>
        <member name="M:XFramework.ProtocolBytes.GetDouble">
            <summary>
            将字节数组转化成double
            </summary>
        </member>
        <member name="M:XFramework.ProtocolBytes.Serialize(System.Object,System.Reflection.BindingFlags)">
            <summary>
            序列化
            </summary>
            <param name="obj"></param>
            <param name="bindingAttr"></param>
        </member>
        <member name="M:XFramework.ProtocolBytes.DeSerialize(System.Object,System.Reflection.BindingFlags)">
            <summary>
            反序列化
            </summary>
            <param name="obj"></param>
            <param name="bindingAttr"></param>
        </member>
        <member name="T:XFramework.Extend">
            <summary>
            这个类管理一系列的拓展函数
            以后把System和UnityEngine的扩展分开
            </summary>
        </member>
        <member name="M:XFramework.Extend.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            对枚举器的所以数据进行某种操作
            </summary>
            <typeparam name="T">目标对象</typeparam>
            <param name="value">目标</param>
            <param name="action">操作事件</param>
        </member>
        <member name="M:XFramework.Extend.Convert``1(System.Array)">
            <summary>
            转变数组类型
            </summary>
            <typeparam name="T">目标类型</typeparam>
            <param name="array">原数组</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            根据Key获取字典的一个值
            </summary>
        </member>
        <member name="M:XFramework.Extend.Concat1``1(``0[0:,0:],``0[0:,0:])">
            <summary>
            连接两个数组的第一维返回一个新数组
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XFramework.Extend.Concat0``1(``0[0:,0:],``0[0:,0:])">
            <summary>
            连接两个数组的第二位返回一个新数组
            </summary>
        </member>
        <member name="M:XFramework.Extend.GetPart``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            获取一个二维数组的某一部分并返回
            </summary>
            <param name="array">目标数组</param>
            <param name="base_0">第一维的起始索引</param>
            <param name="base_1">第二维的起始索引</param>
            <param name="length_0">第一维要获取的数据长度</param>
            <param name="length_1">第二维要获取的数据长度</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Concat0``1(``0[0:,0:,0:],``0[0:,0:,0:])">
            <summary>
            拼接三维数组
            </summary>
        </member>
        <member name="M:XFramework.Extend.Concat1``1(``0[0:,0:,0:],``0[0:,0:,0:])">
            <summary>
            拼接三维数组
            </summary>
        </member>
        <member name="M:XFramework.Extend.Concat2``1(``0[0:,0:,0:],``0[0:,0:,0:])">
            <summary>
            拼接三维数组
            </summary>
        </member>
        <member name="M:XFramework.Extend.GetPart``1(``0[0:,0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            获取一个二维数组的某一部分并返回
            </summary>
            <param name="array">目标数组</param>
            <param name="base_0">第一维的起始索引</param>
            <param name="base_1">第二维的起始索引</param>
            <param name="base_2">第三维的起始索引</param>
            <param name="length_0">第一维要获取的数据长度</param>
            <param name="length_1">第二维要获取的数据长度</param>
            <param name="length_2">第三维要获取的数据长度</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.WithOut``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            获取除_exclude之外的集合
            </summary>
            <param name="_sourList"></param>
            <param name="_exclude"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.End``1(System.Collections.Generic.List{``0})">
            <summary>
            获取列表最后一个元素
            </summary>
        </member>
        <member name="M:XFramework.Extend.MoveToEnd``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
        </member>
        <member name="M:XFramework.Extend.InitialToUpper(System.String)">
            <summary>
            首字母大写
            </summary>
        </member>
        <member name="M:XFramework.Extend.AddSpace(System.String,System.Boolean)">
            <summary>
            在大写字符前加空格
            </summary>
            <param name="upper">首字母是否大写</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Invoke(System.Object,System.String,System.Object[])">
            <summary>
            通过反射和函数名调用非公有方法
            </summary>
            <param name="obj">目标对象</param>
            <param name="methodName">函数名</param>
            <param name="objs">参数数组</param>
        </member>
        <member name="M:XFramework.Extend.FindRecursive(UnityEngine.Transform,System.String)">
            <summary>
            找寻名字为name的子物体
            </summary>
        </member>
        <member name="M:XFramework.Extend.ResetDynamics(UnityEngine.Rigidbody)">
            <summary>
            重置刚体
            </summary>
        </member>
        <member name="M:XFramework.Extend.AddRotation(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            将q加上rotation并返回
            </summary>
        </member>
        <member name="M:XFramework.Extend.SubtractRotation(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            将减去rotation并返回
            </summary>
        </member>
        <member name="M:XFramework.Extend.AddCotroledPanel(UnityEngine.UI.Toggle,UnityEngine.GameObject)">
            <summary>
            给Toggle添加受控制的物体
            </summary>
            <param name="toggle"></param>
            <param name="panel"></param>
        </member>
        <member name="M:XFramework.Extend.Right(UnityEngine.Terrain)">
            <summary>
            右边的地形块
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Top(UnityEngine.Terrain)">
            <summary>
            上边的地形块
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Left(UnityEngine.Terrain)">
            <summary>
            左边的地形块
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Bottom(UnityEngine.Terrain)">
            <summary>
            下边的地形块
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Extend.Draw(UnityEngine.Bounds,UnityEngine.Color)">
            <summary>
            绘制一个包围盒
            </summary>
            <param name="bounds"></param>
            <param name="color"></param>
        </member>
        <member name="T:XFramework.Utility">
            <summary>
            使用工具类
            </summary>
        </member>
        <member name="M:XFramework.Utility.SendRay(System.Int32)">
            <summary>
            发射射线并返回RaycastInfo
            </summary>
        </member>
        <member name="M:XFramework.Utility.CreatPrimitiveType(UnityEngine.PrimitiveType,UnityEngine.Vector3,System.Single)">
            <summary>
            创建立方体
            </summary>
            <param name="pos"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Utility.GetPositions(UnityEngine.Transform[])">
            <summary>
            获取一组位置
            </summary>
        </member>
        <member name="M:XFramework.Utility.GetAngles(UnityEngine.Transform[])">
            <summary>
            获取一组欧拉角
            </summary>
        </member>
        <member name="M:XFramework.Utility.DebugActionRunTime(System.Action)">
            <summary>
            执行一个方法并返回它的执行时间
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Utility.IO.Serialize(System.Object)">
            <summary> 
             序列化 
             </summary> 
             <param name="data">要序列化的对象</param> 
             <returns>返回存放序列化后的数据缓冲区</returns> 
        </member>
        <member name="M:XFramework.Utility.IO.Deserialize(System.Byte[])">
            <summary> 
            反序列化 
            </summary> 
            <param name="data">数据缓冲区</param> 
            <returns>对象</returns> 
        </member>
        <member name="M:XFramework.Utility.IO.Compress(System.Byte[])">
            <summary>
            压缩字节数组
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:XFramework.Utility.IO.Decompress(System.Byte[])">
            <summary>
            解压缩字节数组
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:XFramework.Utility.IO.OpenFile(System.String)">
            <summary>
            打开一个文件
            </summary>
            <param name="fllePath"></param>
        </member>
        <member name="M:XFramework.Utility.IO.CreateFolder(System.String,XFramework.CreatType)">
            <summary>
            创建文件夹
            </summary>
        </member>
        <member name="M:XFramework.Utility.IO.CreateFile(System.String,XFramework.CreatType)">
            <summary>
            创建文件
            </summary>
        </member>
        <member name="M:XFramework.Utility.IO.DeleteFolder(System.String)">
            <summary>
            删除文件夹
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_RED">
            <summary>
            红色
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_ORANGE">
            <summary>
            橙色 
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_YELLOW">
            <summary>
            黄色
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_GREEN">
            <summary>
            绿色
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_BLUE">
            <summary>
            蓝色 
            </summary>
        </member>
        <member name="F:XFramework.Utility.COLOR_PURPLE">
            <summary>
            紫色
            </summary>
        </member>
        <member name="P:XFramework.Utility.IsActive">
            <summary>
            日志是否激活
            </summary>
        </member>
        <member name="M:XFramework.Utility.Log(System.Object)">
            <summary>
            打印信息
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:XFramework.Utility.Log(System.String,System.Object[])">
            <summary>
            打印信息
            </summary>
        </member>
        <member name="M:XFramework.Utility.LogColor(System.String,System.Object)">
            <summary>
            打印彩色信息
            </summary>
            <param name="color"></param>
            <param name="message"></param>
        </member>
        <member name="M:XFramework.Utility.LogColor(System.String,System.String,System.Object[])">
            <summary>
            打印彩色信息
            </summary>
            <param name="color"></param>
            <param name="message"></param>
        </member>
        <member name="M:XFramework.Utility.LogWarning(System.Object)">
            <summary>
            打印警告
            </summary>
        </member>
        <member name="M:XFramework.Utility.LogWarning(System.String,System.Object[])">
            <summary>
            打印警告
            </summary>
        </member>
        <member name="M:XFramework.Utility.LogError(System.Object)">
            <summary>
            打印错误
            </summary>
        </member>
        <member name="M:XFramework.Utility.LogError(System.String,System.Object[])">
            <summary>
            打印错误
            </summary>
        </member>
        <member name="M:XFramework.Utility.GUI(System.String)">
            <summary>
            在Game窗口显示一条日志消息
            </summary>
            <param name="content"></param>
        </member>
        <member name="T:XFramework.Utility.Reflection">
            <summary>
            反射相关的工具
            </summary>
        </member>
        <member name="M:XFramework.Utility.Reflection.CreateInstance``1(System.Object[])">
            <summary>
            创建一个对象
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="objs">参数</param>
        </member>
        <member name="M:XFramework.Utility.Reflection.CreateInstance``1(System.Type,System.Object[])">
            <summary>
            创建一个对象
            </summary>
            <typeparam name="T">对象类型</typeparam>
            <param name="type">类型</param>
            <param name="objs">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:XFramework.Utility.Text.SplitPathName(System.String)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:EventArgs">
            <summary>
            事件参数
            </summary>
        </member>
        <member name="T:EventDispatcher">
            <summary>
            事件分发处理类
            这是个基类
            </summary>
        </member>
        <member name="M:EventDispatcher.DispatchEvent(EventDispatchType,System.Object)">
            <summary>
            分发消息
            </summary>    
            <param name="eventType"></param>
            <param name="data"></param>
        </member>
        <member name="M:EventDispatcher.RegistEvent(System.Action{System.Object,EventArgs})">
            <summary>
            注册监听
            </summary>
        </member>
        <member name="M:EventDispatcher.UnRegistEvent(System.Action{System.Object,EventArgs})">
            <summary>
            注销监听
            </summary>
        </member>
        <member name="T:EventDispatchType">
            <summary>
            事件分发类型
            </summary>
        </member>
        <member name="T:Net.Common.ProtocolBytes">
            <summary>
            提供了一种基于字节流的协议
            </summary>
        </member>
        <member name="M:Net.Common.ProtocolBytes.Encode">
            <summary>
            编码器
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Common.ProtocolBytes.GetByteLength">
            <summary>
            获取字节数量
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Common.ProtocolBytes.GetDesc">
            <summary>
            协议内容 提取每一个字节并组成字符串 用于查看消息
            </summary>
            <returns></returns>
        </member>
        <member name="M:Net.Common.ProtocolBytes.AddString(System.String)">
            <summary>
            将字符转转为字节数组加入字节流
            </summary>
            <param name="str">要添加的字符串</param>
        </member>
        <member name="M:Net.Common.ProtocolBytes.GetString">
            <summary>
            将字节数组转化为字符串
            </summary>
            <param name="index">索引起点</param>
            <param name="end">为下一个转换提供索引起点</param>
            <returns></returns>
        </member>
        <member name="M:Net.Common.ProtocolBytes.AddInt32(System.Int32)">
            <summary>
            将Int32转化成字节数组加入字节流
            </summary>
            <param name="num">要转化的Int32</param>
        </member>
        <member name="M:Net.Common.ProtocolBytes.GetInt32">
            <summary>
            将字节数组转化成Int32
            </summary>
        </member>
        <member name="M:Net.Common.ProtocolBytes.AddFloat(System.Single)">
            <summary>
            将float转化成字节数组加入字节流
            </summary>
            <param name="num">要转化的float</param>
        </member>
        <member name="M:Net.Common.ProtocolBytes.GetFloat">
            <summary>
            将字节数组转化成float
            </summary>
        </member>
        <member name="F:Net.Common.NetData.dataType">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="F:Net.Common.NetData.data">
            <summary>
            数据
            </summary>
        </member>
        <member name="T:Math2d">
            <summary>
            和2d数学相关的算法
            </summary>
        </member>
        <member name="M:Math2d.SegmentIntersection(UnityEngine.Vector2@,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            判断两线段的是否相交
            </summary>
            <param name="intersection">交点</param>
            <param name="point_0"></param>
            <param name="point_1"></param>
            <param name="point_2"></param>
            <param name="point_3"></param>
            <returns></returns>
        </member>
        <member name="F:Math2d.gaussianCoreDic">
            <summary>
            高斯核的静态存储
            </summary>
        </member>
        <member name="M:Math2d.ZoomBilinearInterpAsync(System.Single[0:,0:],System.Int32,System.Int32)">
            <summary>
            双线性差值
            </summary>
            <param name="array_In"></param>
            <param name="newWidth"></param>
            <param name="newHeight"></param>
            <returns></returns>
        </member>
        <member name="M:Math2d.BilinearInterp(System.Single[0:,0:],System.Int32,System.Int32)">
            <summary>
            双线性差值
            </summary>
            <param name="array"></param>
            <param name="length_0"></param>
            <param name="length_1"></param>
            <returns></returns>
        </member>
        <member name="M:Math2d.GaussianBlurAsync(System.Single[0:,0:],System.Single,System.Int32,System.Boolean)">
            <summary>
            对二维数组做高斯模糊
            </summary>
            <param name="array">要处理的数组</param>
            <param name="dev"></param>
            <param name="r">高斯核扩展半径</param>
            <param name="isCircle">改变形状是否是圆</param>
        </member>
        <member name="M:Math2d.GaussianBlur(System.Single[0:,0:],System.Single,System.Int32,System.Boolean)">
            <summary>
            对二维数组做高斯模糊
            </summary>
            <param name="array">要处理的数组</param>
            <param name="dev"></param>
            <param name="r">高斯核扩展半径</param>
            <param name="isCircle">改变形状是否是圆</param>
        </member>
        <member name="T:GameCoordinate">
            <summary>
            坐标系
            </summary>
        </member>
        <member name="F:GameCoordinate.origin">
            <summary>
            坐标原点在世界中的位置
            </summary>
        </member>
        <member name="F:GameCoordinate.theta">
            <summary>
            和世界坐标系的夹角(y轴向x轴方向)
            </summary>
        </member>
        <member name="T:SFramework.Mathematics.PhysicsMath">
            <summary>
            所有物理数学相关计算方法
            </summary>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetTargetVector(UnityEngine.Vector2,System.Single)">
            <summary>
            获取平面向量向右旋转theta后的目标向量
            </summary>
            <param name="startVector"></param>
            <param name="theta"></param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetTargetVector(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            获取三维空间向量绕已知轴旋转θ角后的得到的向量
            </summary>
            <param name="startVector">待旋转向量</param>
            <param name="n">旋转轴</param>
            <param name="theta">旋转角度(弧度)</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetRangeArray(System.Int32[],System.Int32,System.Int32)">
            <summary>
            从一个数组中取固定位置子数组
            </summary>
            <param name="SourceArray"> 原始数组 </param>
            <param name="StartIndex"> 起始位置 </param>
            <param name="EndIndex"> 终止位置 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetIntersectionPoint(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
             <summary>
            求两直线的交点坐标
            给定两个点P1和P2，直线上的点为P
            参数方程：
               P＝ P1 ＋ t*(P2-P1）
            展开就是
               p.x = p1.x + t*(p2.x-p1.x)
               p.y = p1.y + t*(p2.y-p1.y)
               p.z = p1.z + t*(p2.z-p1.z)
            这种写法就比用等式的好，因为不存在分母为0的问题
             </summary>
             <param name="pn1">L1上的点</param>
             <param name="pn2">L1上的点</param>
             <param name="pn3">L2上的点</param>
             <param name="pn4">L2上的点</param>
             <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetHorizontalDir(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            获取两点间向右的水平垂直向量，忽略Y轴
            </summary>
            <param name="_start"> 起始点 </param>
            <param name="_end"> 终止点 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetVerticalDir(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            获取两点间向上的竖直垂直向量
            </summary>
            <param name="_start"> 起始点 </param>
            <param name="_end"> 终止点 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetRect(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            获取两点组成的矩形边框
            </summary>
            <param name="_start">起始点</param>
            <param name="_end">终止点</param>
            <param name="_width">宽度</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetBezierList(UnityEngine.Vector3[],System.Int32)">
            <summary>
            获取贝塞尔曲线(3个点为二次,4个点为三次,其他返回空)
            </summary>
            <param name="_points">控制点集</param>
            <param name="_count">曲线段数</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetBezierPoint(System.Single,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            获取二次贝塞尔曲线上点
            </summary>
            <param name="_t">间隔</param>
            <param name="_P0">起始点</param>
            <param name="_P1">控制点</param>
            <param name="_P2">末尾点</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetBezierPoint(System.Single,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            获取三次贝塞尔曲线上点
            </summary>
            <param name="_t">间隔</param>
            <param name="_P0">起始点</param>
            <param name="_P1">控制点1</param>
            <param name="_P2">控制点2</param>
            <param name="_P3">末尾点</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetPoints(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>         
            获取曲线上面的所有路径点
            </summary> 
            <returns>The list.</returns> 
            <param name="wayPoints">路点列表</param> 
            <param name="pointSize">两个点之间的节点数量</param> 
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.PathControlPointGenerator(UnityEngine.Vector3[])">
            <summary> 
            获取控制点 
            </summary> 
            <returns>The control point generator.</returns> 
            <param name="path">Path.</param> 
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.Interp(UnityEngine.Vector3[],System.Single)">
            <summary> 
            根据 T 获取曲线上面的点位置 ，
            插值函数，
            Hermit曲线方程
            </summary> 
            <param name="pts">控制点点集</param> 
            <param name="t">分割进度</param> 
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetCirclePoints(UnityEngine.Vector3,System.Single,System.Int32)">
            <summary>
            获取半径为r的圆的点坐标集合
            </summary>
            <param name="origin"> 圆心 </param>
            <param name="radius"> 半径 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetEllipsePoints(System.Single,System.Single,UnityEngine.Vector3,System.Int32)">
            <summary>
            获取椭圆上的点
            </summary>
            <param name="_r">短轴</param>
            <param name="_R">长轴</param>
            <param name="_origin">中点</param>
            <param name="seg">间隔</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetSectorPoints_1(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            获取扇形区域的点集合（包括圆心点）
            </summary>
            <param name="origin">圆心点</param>
            <param name="egdePoint">扇形弧边右边缘点</param>
            <param name="angleDiffer">x，z轴张角</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetSectorPoints_2(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            获取扇形区域的点集合（包括圆心点）没有地平线以下的区域
            </summary>
            <param name="origin">圆心点</param>
            <param name="tarPoint"></param>
            <param name="alpha">x,z轴张角</param>
            <param name="theta">x,y轴张角</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.DrawPolygon(System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            <summary>
            获取凹多边形平面排序
            </summary>
            <param name="points"> 关键点集合 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.IsFragementIndex(System.Int32,System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            <summary>
            是否是可划分顶点:新的多边形没有顶点在分割的三角形内
            </summary>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.IsPointInsidePolygon(UnityEngine.Vector3,System.Collections.Generic.List{UnityEngine.Vector3},System.Boolean)">
            <summary>
            判断点是否在多边形区域内
            </summary>
            <param name="p">待判断的点，格式：{ x: X坐标, y: Y坐标 }</param>
            <param name="poly">多边形顶点，数组成员的格式同</param>
            <returns>true:在多边形内，凹点   false：在多边形外，凸点</returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.IsPointInsidePolygon001(UnityEngine.Vector3,System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            判断点是否在多边形区域内
            </summary>
            <param name="point"> 待判断的点 </param>
            <param name="mPoints"> 多边形 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.IsPointInsidePolygon001(UnityEngine.Vector3,System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            判断点是否在多边形区域内
            </summary>
            <param name="point"> 待判断的点 </param>
            <param name="mPoints"> 多边形 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.PolygonToTriangles(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            将一个多边形转化为多个三角形
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetPointsInTriangle(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            返回三角形的内部(整数)顶点
            </summary>
            <param name="trianglePoints">三角形的三个顶点</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetPointsInTriangle(UnityEngine.Vector3[],System.Single,System.Single)">
            <summary>
            通过给定网格间隔，获取三角形内部的网格点
            </summary>
            <param name="trianglePoints">三角形顶点</param>
            <param name="pieceX">X的间隔</param>
            <param name="pieceZ">Z的间隔</param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetVertices(UnityEngine.Vector3,System.Single,System.Int32)">
            <summary>
            获取一个球面表面的所有点坐标集合
            </summary>
            <param name="fromPos">球心</param>
            <param name="radius">半径</param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.Sort3(System.Int32)">
            <summary>
            从上而下顺时针排列三角形顶点渲染顺序
            </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetAirCorridorSpace(System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single)">
            <summary>
            Resion 1.0 获取空中走廊所有顶点(按节数排列)
            </summary>
            侧面与地面垂直，连接处是角，连接处连接于底面平行
            <param name="_list"> 路径点 </param>
            <param name="_width"> 宽度 </param>
            <param name="_height"> 高度 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetAirSpaceBottomPoints(System.Collections.Generic.List{UnityEngine.Vector3},System.Single,System.Single)">
            <summary>
            Resion 2.0 获取空中走廊下表面点集(顶角边)
            </summary>
            <param name="_list"> 路径点 </param>
            <param name="_width"> 宽度 </param>
            <param name="_height"> 高度 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.GetAirBottomSpaceWithSector(System.Collections.Generic.List{UnityEngine.Vector3},System.Single)">
            <summary>
            Resion 2.0 获取空中走廊下表面顶点(弧边)
            </summary>
            <param name="_bottomList"> 下表面点集 </param>
            <param name="_width"> 宽度 </param>
            <param name="_height"> 高度 </param>
            <returns></returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.ComputePolygonArea(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            计算多边形面积(忽略y轴)
            </summary>
            <param name="points"></param>
            <returns>平方米</returns>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.LineLineIntersection(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            计算线段是否相交
            端点相交不算相交
            </summary>
        </member>
        <member name="M:SFramework.Mathematics.PhysicsMath.IsApproximately(System.Double,System.Double,System.Double)">
            <summary>
            计算两个数字是否接近相等,阈值是dvalue
            </summary>
        </member>
        <member name="T:SplineMode">
            <summary>
            样条类型
            </summary>
        </member>
        <member name="T:SplineCurve">
            <summary>
            样条曲线
            </summary>
        </member>
        <member name="F:SplineCurve.startNode">
            <summary>
            曲线起始节点
            </summary>
        </member>
        <member name="F:SplineCurve.endNode">
            <summary>
            曲线终结点
            </summary>
        </member>
        <member name="F:SplineCurve.nodeList">
            <summary>
            节点集合
            </summary>
        </member>
        <member name="F:SplineCurve.tangentsList">
            <summary>
            节点法线集合
            </summary>
        </member>
        <member name="P:SplineCurve.segmentList">
            <summary>
            曲线段集合
            </summary>
        </member>
        <member name="P:SplineCurve.mode">
            <summary>
            曲线构造类型
            </summary>
        </member>
        <member name="M:SplineCurve.AddCatmull_RomControl">
            <summary>
            
            </summary>
        </member>
        <member name="M:SplineCurve.AddNode(UnityEngine.Vector3,System.Single)">
            <summary>
            添加节点
            </summary>
            <param name="newNode"></param>
        </member>
        <member name="M:SplineCurve.GetPoint(System.Int32,System.Single)">
            <summary>
            获取点
            </summary>
            <param name="index"></param>
            <param name="t"></param>
        </member>
        <member name="M:SplineCurve.GetTangents(System.Int32,System.Single)">
            <summary>
            获取切线
            </summary>
            <param name="index"></param>
            <param name="t"></param>
        </member>
        <member name="M:SplineCurve.CaculateTangents(System.Int32)">
            <summary>
            计算曲线段首尾切线
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:CurveSegement">
            <summary>
            曲线段
            </summary>
        </member>
        <member name="F:CurveSegement.rootCurve">
            <summary>
            所属曲线
            </summary>
        </member>
        <member name="P:CurveSegement.startNode">
            <summary>
            曲线段起始位置
            </summary>
        </member>
        <member name="P:CurveSegement.endNode">
            <summary>
            曲线段末尾位置
            </summary>
        </member>
        <member name="P:CurveSegement.c">
            <summary>
            张力系数
            </summary>
        </member>
        <member name="M:CurveSegement.GetPoint(System.Single)">
            <summary>
            获取点
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:CurveSegement.GetTangents(System.Single)">
            <summary>
            获取切线
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Node">
            <summary>
            曲线节点
            </summary>
        </member>
        <member name="F:Node.pos">
            <summary>
            节点位置
            </summary>
        </member>
        <member name="F:Node.preNode">
            <summary>
            前连接节点
            </summary>
        </member>
        <member name="F:Node.nextNode">
            <summary>
            后连接节点
            </summary>
        </member>
        <member name="T:InputEvent">
            <summary>
            鼠标连续点击
            </summary>
        </member>
        <member name="F:InputEvent.activeSingleClick">
            <summary>
            是否响应单击事件
            </summary>
        </member>
        <member name="F:InputEvent.inteval">
            <summary>
            连击的最长间隔
            </summary>
        </member>
        <member name="M:InputEvent.RepeatKey(UnityEngine.KeyCode,System.Int32)">
            <summary>
            连击
            </summary>
            <param name="key"></param>
            <param name="clickCount"></param>
            <returns></returns>
        </member>
        <member name="M:InputEvent.CombineKey(UnityEngine.KeyCode,UnityEngine.KeyCode)">
            <summary>
            组合按键
            </summary>
            <param name="firstKey"></param>
            <param name="sencondKey"></param>
            <returns></returns>
        </member>
        <member name="M:InputEvent.GetKeyDown(UnityEngine.KeyCode)">
            <summary>
            替代Input.GetKeyDown
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:InputEvent.GetKeyUp(UnityEngine.KeyCode)">
            <summary>
            替代Input.GetKeyUp
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:Timer._isRunning">
            <summary>
            是否执行
            </summary>
        </member>
        <member name="F:Timer._useTime">
            <summary>
            已执行时间（每次满足运行间隔就会加这个）
            </summary>
        </member>
        <member name="P:Timer.RunTime">
            <summary>
            运行时间
            </summary>
        </member>
        <member name="P:Timer.UseCount">
            <summary>
            已运行次数
            </summary>
        </member>
        <member name="P:Timer.TimeInterval">
            <summary>
            运行间隔
            </summary>
        </member>
        <member name="P:Timer.RepeatCount">
            <summary>
            设置的运行次数
            </summary>
        </member>
        <member name="M:Timer.#ctor(System.Single,System.Int32)">
            <summary>
            <param name="interval">时间间隔，单位是毫秒</param>
            <param name="repeatCount">运行次数，一秒一次的话MaxValue可以执行68年</param>
            </summary>
        </member>
        <member name="P:Timer.IsRunning">
            <summary>
            是否运行中
            </summary>
        </member>
        <member name="M:Timer.Update(System.Single)">
            <summary>
            每帧执行
            </summary>
            <param name="deltaTime"></param>
        </member>
        <member name="M:Timer.AddEventListener(System.Action)">
            <summary>
            添加事件
            </summary>
            <param name="type"></param>
            <param name="fun"></param>
        </member>
        <member name="M:Timer.RemoveEventListener(System.Action)">
            <summary>
            移除事件
            </summary>
            <param name="type"></param>
            <param name="fun"></param>
        </member>
        <member name="M:Timer.Start">
            <summary>
            开始(调用了IsRunning的Set,初始化了TimerManager)
            </summary>
        </member>
        <member name="M:Timer.Pause">
            <summary>
            停止
            </summary>
        </member>
        <member name="M:Timer.ReSet">
            <summary>
            重置
            </summary>
        </member>
        <member name="T:Timer.TimerManager">
            <summary>
            计时器管理
            除了计时器以外其他类暂时不需要调用，以后需要再放到外面去
            </summary>
        </member>
        <member name="T:MonoEvent">
            <summary>
            Mono生命周期事件
            一些不继承Mono的类如果想在Mono生命周期做一些事，可以往这里添加
            </summary>
        </member>
        <member name="T:MonoSingleton`1">
            <summary>
            此单例继承于Mono，不需要手动创建
            </summary>
        </member>
        <member name="M:MonoSingleton`1.OnApplicationQuit">
            <summary>
            当工程运行结束，在退出时机时候，不允许访问单例
            </summary>
        </member>
        <member name="T:Singleton`1">
            <summary>
            不继承mono的单例基类，如果需要Update，可以将方法注册进MonoEvent的事件中
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
